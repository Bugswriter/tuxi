#!/usr/bin/env sh

###############################
#####      Constants      #####
###############################

# setting this overrides the system language variable
# this can also be set in your shell environment with TUXI_LANG=
# the -l commandline flag overrides everything
[ -n "$TUXI_LANG" ] && LANGUAGE="$TUXI_LANG" || LANGUAGE=""

# if you find more than one answer is being printed (and you're not using -a)
# increase this number by a little (you want it to be as low as possible)
# this can also be set in your shell environment with TUXI_DELAY=
[ -n "$TUXI_DELAY" ] && MICRO_DELAY="$TUXI_DELAY" || MICRO_DELAY=250

VERSION="dev 2.0"
MAIN_PID="$$"
[ ! "$XDG_CACHE_HOME" ] && XDG_CACHE_HOME="$HOME/.cache"

#########################################
#####      macOS compatibility      #####
#########################################

# credit to @Zhann in #149

if [ "$OSTYPE" = 'darwin'* ]; then
    sed() {
        gsed "$@"
    }
    paste() {
        gpaste "$@"
    }
fi

######################################
#####      Snippet priority      #####
######################################

# this variable determines the order the tests are started, they are processed in parallel
# even though these are started in order, by default, the first answer to resolve is the one printed
# the order here might only make a very small difference

# the first word should be the name of the a_function() followed by a space
# you can disable tests by commenting out the line(s)
# IMPORTANT! - richcast must remain top and active
# it's slower to process than the other scrapes that get a cast list so it needs to start first
# also I've put a small delay between starting that and the other scrapes
# this is a temporary hack until I get a chance to look at speeding up the snippet
priority="
richcast        # Rich Rich Answers ( eg: social network cast )
define          # Define ( eg: define Aggrandize )
lists           # Simple lists ( eg Need for Speed Heat cars list )
kno_val         # Chem facts ( eg: density of silver, density of hydrogen, what is the triple point of oxygen )
pronounce       # Learn to pronounce ( eg: pronounce linux )
lyrics_int      # Lyrics ( eg: gecgecgec lyrics )
weather         # Weather ( eg: weather new york )
math            # Math ( eg: log_2(3) * pi^e )
unit            # Units Conversion ( eg: 1m into 1 cm )
currency        # Currency Conversion ( eg: 1 USD in rupee )
kno_top         # Knowledge Graph - top ( list ) ( eg: the office cast )
rich            # Rich Answers ( eg: elevation of mount everest )
basic           # Basic Answers ( eg: christmas day )
feat            # Featured Snippets ( eg: who is garfield )
quotes          # Quotes ( eg: mahatma gandhi quotes )
trans           # Translate ( eg: Vais para cascais? em ingles )
sport_fixture   # Shows last or next fixture of a sports team ( eg. Chelsea next game )
lyrics_us       # Lyrics for US users, above does not work for US
kno_right       # Knowledge Graph - right ( eg: the office )
"

##############################
#####      Defaults      #####
##############################

# system language fallback
LANG=$(echo $LANG | sed 's/\..*//')

# options
raw=false
quiet=false
all=false
best_match=false
pick_search=false
debug=false
save_html=false
use_cache=false
pick_lang=false
no_pipe=false

# color codes
N="\033[0m"    # Reset
B="\033[1m"    # Bold
R="\033[1;31m" # Red
G="\033[1;32m" # Green
Y="\033[1;33m" # Yellow
M="\033[1;35m" # Magenta
C="\033[1;36m" # Cyan

##################################
#####      Help message      #####
##################################

help_text() {
    printf "%bUsage:%b tuxi %b[options]%b %bquery%b\n" "$G" "$N" "$Y" "$N" "$M" "$N"
    printf "%bOR:%b %bquery source%b | tuxi %b[options]%b\n" "$G" "$N" "$M" "$N" "$Y" "$N"
    printf "\n"
    printf "%bOptions:%b\n" "$G" "$N"
    printf "  -h                    Show this help message and exit.\n"
    printf "  -v                    Print tuxi version info and exit.\n"
    printf "\n"
    printf "  -r                    Raw search results.\n"
    printf "                        (no pretty output, no colors)\n"
    printf "\n"
    printf "  -q                    Only output search results.\n"
    printf "                        (silences \"Did you mean?\", greeting, usage)\n"
    printf "\n"
    printf "  -a                    Prints all valid answers.\n"
    printf "\n"
    printf "  -b                    Tries to select the best answer based on keywords at the start and end of your query.\n"
    printf "                        (experimental - eg: define WORD, SONG lyrics, PERSON quotes, weather CITY, FILM cast)\n"
    printf "\n"
    printf "  -t                    Pick answers to test.\n"
    printf "                        (you can specify multiple answers using tuxi_NAME in your query)\n"
    printf "\n"
    printf "  -l                    use LANG_[lang] in your query to override the language used\n"
    printf "                        (eg: tuxi -l LANG_en_US my search query)\n"
    printf "\n"
    printf "%btuxi supports the following environment variables:%b\n" "$G" "$N"
    printf "  TUXI_LANG=[lang]      sets default search language (eg: TUXI_LANG='en_US')\n"
    printf "\n"
    printf "  TUXI_DELAY=[int]      if you find more than one answer is being printed (and you're not using -a)\n"
    printf "                        increase this number by a little (you want it to be as low as possible)\n"
    printf "                        default value is 250 (eg: TUXI_DELAY=270)\n"
    printf "\n"
    printf "%bdeveloper flags:%b\n" "$G" "$N"
    printf "  -d                    prints debug info along with results\n"
    printf "  -s                    saves HTML for this query to $XDG_CACHE_HOME/tuxi/[date]-[query].html\n"
    printf "\n"
    printf "  -c                    use most recent cached result and query\n"
    printf "                        this can be combined with -t flag to more quickly test for different answers\n"
    printf "\n"
    printf "  -p                    disable pipe support (it can break some scripts including our own test script)\n"
    printf "\n"
    printf "%bReport bugs at%b %bhttps://github.com/Bugswriter/tuxi/issues%b\n" "$G" "$N" "$C" "$N"
}

#############################
#####      Getopts      #####
#############################

# -r : raw output
# -v : version info
# -h : help
# -q : silences greeting and did you mean
# -a : print all answers
# -b : best match
# -t : specify answer type
# -l : specify language using LANG_[code] - eg LANG_en_US
# -d : print debug info
# -s : save google HTML response
# -c : use most recent cached results
# -p : disable pipe support (needed for test script)
while getopts "rvhqabtldscp" OPT; do
    case "$OPT" in
    r)
        raw=true
        ;;
    v)
        printf "tuxi %s\n" "$VERSION"
        exit 0
        ;;
    h)
        help_text
        exit 0
        ;;
    q)
        quiet=true
        ;;
    a)
        all=true
        ;;
    b)
        best_match=true
        ;;
    t)
        pick_search=true
        ;;
    d)
        debug=true
        ;;
    s)
        save_html=true
        ;;
    c)
        use_cache=true
        ;;
    l)
        pick_lang=true
        ;;
    p)
        no_pipe=true
        ;;
    *)
        help_text | head -n 1
        exit 1
        ;;
    esac
done
# shifts to query
shift $((OPTIND - 1))
$pick_search && $best_match && echo "sorry but -b and -t mutually exclusive" && exit 1

#//TODO this may need reworking later to use read instead and only capture the first line
# question | tuxi [-flags] --> answer :)
if ! $no_pipe; then
    [ -p /dev/stdin ] && query=$(cat)
fi

#######################################
#####      Output formatting      #####
#######################################

# search result output format (changes if raw=true)
output() {
    printf "%b---%b\n%s\n%b---%b\n" "$G" "$N" "$*" "$G" "$N"
}

# If raw=true: No colors, No pretty output
if $raw; then
    N=""
    B=""
    R=""
    G=""
    Y=""
    M=""
    C=""

    output() {
        printf "%s\n" "$*"
    }
fi

info_msg() {
    printf "%b>%b %s\n" "$G" "$N" "$*"
}

error_msg() {
    printf "%b%s%b\n" "$R" "$*" "$N"
}

######################################
#####      Dependency check      #####
######################################

# Checks if dependencies are installed.
check_deps() {
    while [ -n "$1" ]; do
        if [ ! "$(command -v $1)" ]; then
            error_msg "\"$1\" not found!"
            exit 2
        fi
        shift
    done
}

# pup : https://github.com/ericchiang/pup
# recode : https://github.com/rrthomas/recode
# jq : https://github.com/stedolan/jq
check_deps "pup" "recode" "jq"

########################################
#####      Query manipulation      #####
########################################

# If query is empty and -c is passed: use query from cached result
# If query is empty (no -c): exit
# If quiet=false: Prints greeting and usage
if [ -z "$1" ] && [ -z "$query" ]; then
    if ! $use_cache; then
        if ! $quiet; then
            printf "Hi, I'm Tuxi. Ask me anything!\n"
            help_text | head -n 1
        fi
        exit 0
    else
        query=$(ls -1t $XDG_CACHE_HOME/tuxi | head -n1 | sed -e 's/tuxi-*[0-9]*-//' -e 's/.html//' -e 's/_/ /g')
    fi
fi

# Else, all arguments are saved in $query
[ -z "$query" ] && query="$*"

# language select: the -l flag
# language specified on the command line overwrites both
# the variable set at the top of this script and the system language
if $pick_lang; then
    query="$(printf '%b\n' "$query" | sed 's/ /\\n/g')"
    LANGUAGE="$(printf '%b\n' "$query" | grep 'LANG_' | sed 's/LANG_//g')"
    query="$(printf '%b\n' "$query" | grep -v "LANG_" | sed 's/\\n/ /g')"
fi

# Custom answers: the -t flag
# clears the list of snippets to check (saving the original list to print out if a mistake is made)
# then loops through the query looking for tuxi_ and updates the priority variable to use only those snippets
if $pick_search; then
    list_priority="$priority"
    snippet_check=$(printf '%b\n' "$list_priority" | cut -d ' ' -f1 | sed -e '/^\s*#.*$/d' -e '/^\s*$/d')
    matched=false
    priority=""
    query="$(printf '%b\n' "$query" | sed 's/ /\\n/g')"
    for pick_words in $(printf '%b\n' "$query" | grep 'tuxi_' | sed 's/tuxi_//g'); do
        for check_pick_words in $(printf '%b\n' "$snippet_check"); do
            if [ "$check_pick_words" = "$pick_words" ]; then
                [ -z "$priority" ] && priority="$(printf '%s\n' "$pick_words")" \
                    || priority="$(printf '%b\n%s\n' "$priority" "$pick_words")"
                matched=true
            fi
        done
        if ! $matched; then
            printf "Sorry but %s is not a valid search type\nPlease retry your search using one of the following: tuxi_\n" "$pick_words"
            printf "%b\n" "$list_priority"
            printf "\n"
            printf "If %s is on that list could you please file a bug report, thanks! (and sorry)\n" "$pick_words"
            exit 1
        fi
    done
    query="$(printf '%b\n' "$query" | grep -v "tuxi_" | sed 's/\\n/ /g')"
fi

# our patented (honest!) "smrt search" algorithm: the -b flag
# jokes aside, this is going to need some iterating on, I'll turn it into a tidy loop later
if $best_match; then
    j=7
    use_quotes=false
    use_lyrics=false
    use_weather=false
    use_cast=false
    use_weather=false
    use_define=false
    use_list=false
    use_pronounce=false

    query_check="$(printf '%b\n' "$query" | sed 's/ /\\n/g' | tr '[:upper:]' '[:lower:]')"
    first_word=$(printf '%b\n' "$query_check" | head -n1)
    last_word=$(printf '%b\n' "$query_check" | tail -n1)

    for keywords in printf '%s\n%s\n' "$first_word" "$last_word"; do
        case "$keywords" in
        quote | quotes) use_quotes=true ;;
        lyrics) use_lyrics=true ;;
        weather) use_weather=true ;;
        cast) use_cast=true ;;
        define | definition) use_define=true ;;
        list) use_list=true ;;
        pronounce | pronunciation) use_pronounce=true ;;
        esac
    done

    $use_quotes && priority="$(printf '%b\n' "$priority" | cut -d ' ' -f1 | grep 'quotes')" || j=$(($j - 1))
    $use_lyrics && priority="$(printf '%b\n' "$priority" | cut -d ' ' -f1 | grep 'lyrics')" || j=$(($j - 1))
    $use_weather && priority="$(printf '%b\n' "$priority" | cut -d ' ' -f1 | grep 'weather')" || j=$(($j - 1))
    $use_cast && priority="$(printf '%b\n' "$priority" | cut -d ' ' -f1 | grep -e 'rich' -e 'lists' -e 'kno_')" || j=$(($j - 1))
    $use_define && priority="$(printf '%b\n' "$priority" | cut -d ' ' -f1 | grep 'define')" || j=$(($j - 1))
    $use_pronounce && priority="$(printf '%b\n' "$priority" | cut -d ' ' -f1 | grep 'pronounce')" || j=$(($j - 1))
    $use_list && priority="$(printf '%b\n' "$priority" | cut -d ' ' -f1 | grep -e 'rich' -e 'lists' -e 'kno_')" || j=$(($j - 1))
    [ $j -eq 0 ] && priority="$(printf '%b\n' "$priority" | cut -d ' ' -f1 | sed -e '/^\s*#.*$/d' -e '/^[[:space:]]*$/d' | grep -v 'quotes' | grep -v 'lyrics' | grep -v 'weather')"
fi

######################################
#####      Answer functions      #####
######################################

## NOTE: the order of these functions doesn't matter, priority is determined by the variable

## FUNCTION TEMPLATE
# NewAnswerName should be the word used in $priority

# a_NewAnswerName() { # Answer description (and example)
#     echo "$google_html" | pup ... [ SCRAPE METHOD HERE ] ...
# }

a_define() { # Define (eg: define Aggrandize) //original snippet credit @igaurab
    define="$(echo "$google_html" | pup 'div.VpH2eb.dZd3De.vmod text{}' | sed '/^[[:space:]]*$/d' | recode html..ISO-8859-1)"
    if [ -n "$define" ]; then
        printf 'pronounced: %b%s%b\n\n' "$C" "$(printf '%s\n' "$define" | grep -m1 -A1 '/' | tail -n1)" "$N"
        printf '%s\n' "$define" | {
            dfn_counter=1
            while IFS= read -r dfn_trim; do
                case "$dfn_trim" in
                noun | verb | adjective | adverb | pronoun | preposition | conjunction | determiner | exclamation)
                    dfn_counter=$(($dfn_counter + 1))
                    break
                    ;;
                *) dfn_counter=$(($dfn_counter + 1)) ;;
                esac
            done
            return $dfn_counter
        }
        dfn_trim=$(($? - 1))
        define="$(printf '%s\n' "$define" | tail -n +${dfn_trim})"
        printf '%s\n' "$define" | sed -n 2p | grep -q ':'
        if [ $? -eq 0 ]; then
            dfn_start=true
        else
            printf '%b%s%b\n' "$Y" "$(printf '%s\n' "$define" | head -n1)" "$N"
            dfn_start=false
        fi
        define="$(printf '%s\n' "$define" | tail -n +2)"
        dfn_append=false
        dfn_marker=false
        dfn_sim_op=false
        dfn_skip=false
        printf '%s\n' "$define" | while IFS= read -r dfn_foo; do
            if $dfn_append; then
                printf '%b%s%b\n' "$C" "$dfn_foo" "$N"
                dfn_append=false
            elif [ $dfn_foo -eq $dfn_foo ] 2>/dev/null; then
                printf '\n'
                $dfn_sim_op && dfn_sim_op=false
            elif [ "$dfn_foo" = '/' ]; then
                $dfn_skip && dfn_skip=false || dfn_skip=true
            elif $dfn_skip; then
                continue
            elif [ "$dfn_foo" = '. ' ]; then
                $dfn_sim_op && dfn_sim_op=false
            elif [ "$dfn_foo" = '.' ]; then
                printf '\n'
                $dfn_sim_op && dfn_sim_op=false
            elif $dfn_marker; then
                [ "$dfn_foo" = 'Similar:' ] && dfn_hl="$G" || dfn_hl="$R"
                printf '%b%s%b\n' "$dfn_hl" "$dfn_foo" "$N"
                dfn_marker=false
                dfn_sim_op=true
            elif $dfn_start; then
                if [ "$dfn_foo" = 'informal' ]; then
                    printf '(informal) '
                else
                    printf '%s ' "$dfn_foo"
                    dfn_append=true
                    dfn_start=false
                fi
            else
                case "$dfn_foo" in
                "; "*)
                    printf '%s ' "$dfn_foo"
                    dfn_append=true
                    ;;
                *"noun: " | *"verb: " | *"adjective: " | *"adverb: " | *"pronoun: " | *"preposition: " | *"conjunction: " | *"determiner: " | *"exclamation: ")
                    printf '\n%s ' "$dfn_foo"
                    $dfn_sim_op && dfn_sim_op=false
                    dfn_append=true
                    ;;
                " h ")
                    dfn_marker=true
                    ;;
                noun | verb | adjective | adverb | pronoun | preposition | conjunction | determiner | exclamation)
                    printf '\n'
                    $dfn_sim_op && dfn_sim_op=false
                    dfn_start=true
                    ;;
                *)
                    $dfn_sim_op && printf '\t%s\n' "$dfn_foo" \
                        || printf '\t%b%s%b\n' "$B" "$dfn_foo" "$N"
                    ;;
                esac
            fi
        done
    fi
}
a_kno_val() { # Chem facts ( eg: density of silver, density of hydrogen, what is the triple point of oxygen)
    # "what is the " seems to be required for some things //credit @sudocanttype
    echo "$google_html" | pup 'div.Z0LcW.XcVN5d text{}' | tr '\n' ' '
}
a_math() { # Math ( eg: log_2(3) * pi^e ) //credit @BeyondMagic
    echo "$google_html" | pup 'span.qv3Wpe text{}' | tr -d '\n ' | recode html..ISO-8859-1
}
a_kno_top() { # Knowledge Graph - top (list) ( eg: the office cast ) //credit @Bugswriter
    echo "$google_html" | pup 'div.dAassd json{}' | jq -r '.[] | .children | .[] | .text' | sed ':a;N;$!ba;s/\n/ /g;s/null/\n/g' | sed '1s/.*/* &/;2,$s/.*/*&/;$d' | recode html..ISO-8859-1
}
a_quotes() { # Quotes ( eg: mahatma gandhi quotes ) //credit @PoseidonCoder
    echo "$google_html" | pup 'div.Qynugf text{}' | recode html..ISO-8859-1
}
a_basic() { # Basic Answers ( eg: tuxi christmas day ) // @Bugswriter
    echo "$google_html" | pup 'div.zCubwf text{}' | tr -d '\n' | recode html..ISO-8859-1
}
a_richcast() { # Rich Rich Answers ( eg: social network cast ) //credit @BeyondMagic
    echo "$google_html" | pup 'a.ct5Ked json{}' | jq -r '.[] | .title' | sed 's/^/* /' | recode html..ISO-8859-1
}
a_lists() { # Simple lists (eg Need for Speed Heat cars list) //credit @BeyondMagic
    echo "$google_html" | pup 'li.TrT0Xe text{}' | sed -e 's/^ //' -e 's/^/* /' -e 's/\.$//' | recode html..ISO-8859-1
}
a_rich() { # Rich Answers ( eg: elevation of mount everest ) //credit @d-shaun + @Bugswriter
    # I've removed div.mR2gOd from this scrape as it seems to only be providing redundant information
    # if it is needed for some information not provided elsewhere, I'll make it a function
    rich=$(echo "$google_html" | pup 'div.ujudUb, div.XcVN5d text{}' | sed 's/^ //' | recode html..ISO-8859-1)
    if [ $(printf '%b\n' "$rich" | wc -w) -gt 1 ]; then
        if [ "$(printf '%b\n' "$rich" | head -n1)" = 'View all' ]; then
            unset rich
            exit
        else
            printf '%b\n' "$rich"
        fi
    else
        unset rich
    fi
}
a_feat() { # Featured Snippets ( eg: who is garfield ) //credit @Bugswriter
    echo "$google_html" | pup 'span.hgKElc text{}' | tr -d '\n' | recode html..ISO-8859-1 | tr ' ' '\0' | xargs -0 -n10
}
a_lyrics_int() { # Lyrics ( eg: gecgecgec lyrics ) //credit @d-shaun
    echo "$google_html" | pup 'div.bbVIQb text{}' | recode html..ISO-8859-1
}
a_lyrics_us() { # Lyrics for US users, above does not work for US //credit @sudocanttype
    echo "$google_html" | pup 'span[jsname="YS01Ge"] text{}' | recode html..ISO-8859-1
}
a_weather() { # Weather ( eg: weather new york) //credit @jhagas + @Genghius + @BeyondMagic
    weather=$(echo "$google_html" | pup 'div.UQt4rd json{}' | jq -r '.. | .text?, .alt?' | sed '/null/d' | sed '$!N; /^\(.*\)\n\1$/!P; D')
    if [ -n "$weather" ]; then
        if [ $(echo "$weather" | sed -n 2p) -gt $(echo "$weather" | sed -n 3p) ]; then
            weather=$(printf '%b\n' "$weather" | sed -e 2','3'!b' -e ''2'h;'2'!H;'3'!d;x;s/^\([[:print:]'"$(printf '\001\002\003\004\005\006\007\010\011\013\014\015\016\017\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037\177')"']*\)\(.*\n\)\(.*\)/\3\2\1/')
        fi
        printf '%b\n' "$weather" | sed '4,5d;2s/.*/&ºC/;2,${N;s/\n/\t/;};3s/.*/&ºF/;$s/\t/\t\t/' | recode html..ISO-8859-1
    fi
}
a_unit() { # Units Conversion ( eg: 1m into 1 cm ) //credit @karthink
    echo "$google_html" | pup '#NotFQb json{}' | jq -r '.[] | .children | .[0] | .value' | recode html..ISO-8859-1
}
a_currency() { # Currency Conversion ( eg: 1 USD in rupee ) //credit @karthink
    echo "$google_html" | pup '.SwHCTb text{}' | sed 's/\n//g;s/\ /\0/g' | recode html..ISO-8859-1
}
a_trans() { # Translate ( eg: Vais para cascais? em ingles ) //credit @Genghius
    echo "$google_html" | pup 'pre.XcVN5d json{}' | jq -r '[.[] | .children | .[] | select(.class!="BCGytf")][1] | .text' | sed 's/null//g' | recode html..ISO-8859-1
}
a_kno_right() { # Knowledge Graph - right ( eg: the office ) //credit @Bugswriter
    echo "$google_html" | pup 'div.kno-rdesc span' | sed -n '2p' | awk '{$1=$1;print}' | recode html..ISO-8859-1 | tr ' ' '\0' | xargs -0 -n10
}
a_sport_fixture() { # Shows last or next fixture of a sports team ( eg. Chelsea next game ) //credit @ismayilkarimli
    echo "$google_html" | pup 'span.imso_mh__lr-dt-ds, span[jscontroller="f9W5M"], div.liveresults-sports-immersive__team-name-width span, div.imso_mh__l-tm-sc, div.imso_mh__r-tm-sc text{}' | recode html..ISO-8859-1
}
a_pronounce() { # Learn to pronounce ( eg: pronounce linux ) //credit @sdushantha
    echo "$google_html" | pup 'div.fQ02Rb.eDzgme span.seLqNc text{}' | paste -s -d ' ' | sed 's/\s/∙/g'
}

###############################
#####      Functions      #####
###############################

# these are used by the processing loop to determine how and when to print info and exit
found_answer_signal() {
    answers_found=$(($answers_found + 1))
}
trap found_answer_signal USR1
output_printed_signal() {
    printed=$(($printed + 1))
}
trap output_printed_signal USR2

short_delay() {
    [ ! $1 ] && runs=1 || runs=$1
    foo=0
    until [ $foo -eq $runs ]; do
        l=0
        until [ $l -eq $MICRO_DELAY ]; do
            [ true ]
            l=$(($l + 1))
        done
        foo=$(($foo + 1))
    done
}

# calculates execution time and number of answers processed
debug_info() {
    timer_stop=$(date +'%s %N')
    timer_start_secs=$(echo $timer_start | cut -d ' ' -f1)
    timer_stop_secs=$(echo $timer_stop | cut -d ' ' -f1)
    timer_start_nano=$(echo $timer_start | cut -d ' ' -f2)
    timer_start_nano=$(expr $timer_start_nano + 0)
    timer_stop_nano=$(echo $timer_stop | cut -d ' ' -f2)
    timer_stop_nano=$(expr $timer_stop_nano + 0)
    timer_secs_math=$(($timer_stop_secs - $timer_start_secs))
    if [ $timer_secs_math -lt 1 ]; then
        timer_duration=$(($timer_stop_nano - $timer_start_nano))
        timer_duration=$(($timer_duration / 1000))
        if [ $timer_duration -gt 1999 ]; then
            timer_duration=$(($timer_duration / 1000))
            timer_unit='ms'
        else
            timer_unit='μs'
        fi
    elif [ $timer_secs_math -eq 1 ]; then
        timer_duration=$((1000000000 - $timer_start_nano))
        timer_duration=$(($timer_duration + $timer_stop_nano))
        timer_duration=$(($timer_duration / 1000))
        if [ $timer_duration -gt 1999 ]; then
            timer_duration=$(($timer_duration / 1000))
            timer_unit='ms'
        else
            timer_unit='μs'
        fi
    else
        timer_duration="$timer_secs_math"
        timer_unit='s'
    fi
    info_msg "$answers_found answer(s) found - post curl processing time ~$timer_duration $timer_unit"
}

# enabled with the -s flag
dump_html() {
    [ -d "$XDG_CACHE_HOME"/tuxi ] || mkdir -p "$XDG_CACHE_HOME/tuxi"
    file_name="$(date +%s%N)-$(printf %s "$query" | sed 's/ /_/g').html"
    html_location="$XDG_CACHE_HOME/tuxi/$file_name"
    printf "%s" "$google_html" >$html_location
    info_msg "HTML for \"$query\" -> $html_location"
}

# this calls the various snippet functions and checks for valid answers
test_answers() {
    print_answer_signal() {
        if [ -n "$z" ]; then
            kill -USR2 "$MAIN_PID"
            $debug && info_msg "Answer selected: $the_chosen_one"
            output "$z"
            kill "$sleep_pid"
        fi
    }
    trap print_answer_signal USR1
    z="$(a_${1})"
    if [ -n "$z" ]; then
        the_chosen_one="$1"
        if ! $all; then
            kill -USR1 "$MAIN_PID"
            sleep 1 &
            sleep_pid="$!"
            wait
        else
            kill -USR1 "$MAIN_PID"
            $debug && output "$(printf '%b\n\n%b\n' "$(info_msg "Answer selected: $the_chosen_one")" "$z")" || output "$z"
        fi
    fi
}

######################################
#####      Getting the HTML      #####
######################################

# fetch response from Google via cURL (-G: get, -s: silent) unless -c flag is passed
# in which case we use the most recent cached html from $XDG_CACHE_HOME/tuxi
user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:53.0) Gecko/20100101 Firefox/53.0"
google_url="https://www.google.com/search?hl="${LANGUAGE:="${LANG:=en_US}"}""
$use_cache && google_html="$(cat $XDG_CACHE_HOME/tuxi/$(ls -1t $XDG_CACHE_HOME/tuxi | head -n1))"
if [ -z "$google_html" ]; then
    $use_cache && printf 'no cached pages found!\n' && exit 1
    google_html=$(curl -Gs --compressed "$google_url" --user-agent "$user_agent" --data-urlencode "q=$query")
fi
[ -z "$google_html" ] && error_msg "No valid response from google!" && exit 1

# if -s flag is passed save search results for debugging
$save_html && dump_html

# start timer for debug_info after receiving results from google
$debug && timer_start=$(date +'%s %N')

################################
#####      Processing      #####
################################

# launches all the snippet functions and saves the pids for later
pids=""
answers_found=0
printed=0
if ! $pick_search || ! $best_match; then
    priority=$(printf '%b\n' "$priority" | cut -d ' ' -f1 | sed -e '/^\s*#.*$/d' -e '/^[[:space:]]*$/d')
fi
# loops through $priority forking all the tests in order
for tests in $(printf '%b\n' "$priority"); do
    test_answers "$tests" 2>/dev/null &
    if [ -z "$pids" ]; then
        pids="$!"
        short_delay 2
    else
        pids="${pids}\n${!}"
    fi
done

# did you mean is processed here to make controling the order things get printed easier
# forking the tests makes things faster (hopefully) but makes passing information around harder
if ! $quiet; then
    # silenced if quiet=true
    did_you_mean="$(echo "$google_html" | pup 'a.gL9Hy text{}')"
    if [ -n "$did_you_mean" ]; then
        err_hl="$(echo "$google_html" | pup 'a.gL9Hy > b text{}')"
        did_you_mean="$(printf '%b\n' "$did_you_mean" | sed ':a;N;$!ba;s/\n//g' | recode html..ISO-8859-1)"
        for errors in $(printf '%b\n' "$err_hl"); do
            replacement="${C}${errors}${N}${B}"
            replacement=$(printf '%s\n' "$replacement" | sed -e 's/[\/&]/\\&/g')
            did_you_mean=$(printf '%b\n' "$did_you_mean" | sed "s/${errors}/${replacement}/g")
        done
        info_msg "$(printf 'did you mean "%b%b%b" ?\n' "$B" "$did_you_mean" "$N")"
    fi
fi

# loops to spin wheels until an answer has been found
# if all the launched processes exit without an answer being found
# script exits with a "No Result!" message
while [ $answers_found -eq 0 ]; do
    for waiting1 in $(printf '%b\n' "$pids"); do
        kill -0 "$waiting1" 1>/dev/null 2>&1
        [ $? -eq 0 ] && break
        for waiting2 in $(printf '%b\n' "$pids"); do
            kill -0 "$waiting2" 1>/dev/null 2>&1
            [ $? -eq 0 ] && break 2
        done
        error_msg "No Result!"
        $debug && debug_info
        exit 1
    done
done

# now we have our first answer, it's time to print it
# this loops through the child pid list in priority order sending the USR1 kill signal
# if one has an answer ready that is what gets printed out
if ! $all; then
    for lucky_winner in $(printf '%b\n' "$pids"); do
        [ $printed -gt 0 ] && break
        kill -0 "$lucky_winner" 1>/dev/null 2>&1
        if [ $? -eq 0 ]; then
            kill -USR1 "$lucky_winner" 1>/dev/null 2>&1
            short_delay
        fi
    done
fi

# once an answer has been printed and the -a flag isn't active
# kills all remaining child processes
# if -a flag is active then it waits until every answer has been printed first
if ! $all; then
    for kids in $(printf '%b\n' "$pids"); do
        kill -0 "$kids" 1>/dev/null 2>&1
        [ $? -eq 0 ] && kill "$kids" 1>/dev/null 2>&1
    done
fi
$all && wait
# another small delay as wait sometimes doesn't seem to wait quite long enough
# for the last answer to be printed before exiting.
short_delay 2
$debug && debug_info
exit 0
