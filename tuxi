#!/usr/bin/env sh
#
# tuxi is a cli assistant created by Bugswriter
# to get answers for your questions instantly.
# tuxi is currently developed by many collaborators
# you can get more information on our repo :)
#
# https://github.com/Bugswriter/tuxi © GPL-3.0 License

#-----------------------------------------------
# Constants
#-----------------------------------------------

 VERSION='dev 2.1'
MAIN_PID=$$

# Setting this overrides getting the system language variable;
#   The -l commandline flag overrides everything;
#   This can also be set in your shell environment with
#     TUXI_LANG=
[ -n "$TUXI_LANG" ] && LANGUAGE=$TUXI_LANG || LANGUAGE=''

# If you find more than one answer is being printed (and you're not using -a);
#   Increase this number by a little (you want it to be as low as possible);
#   This can also be set in your shell environment with
#     TUXI_DELAY=
[ -n "$TUXI_DELAY" ] && MICRO_DELAY=$TUXI_DELAY || MICRO_DELAY=250

# Setting this in case cache's environment variable is not set;
#   Important in case an option with this feature is enabled.
[ -z "$XDG_CACHE_HOME" ] && XDG_CACHE_HOME="$HOME/.cache"

# Popular user agent to mask in, you can change it to whatever you want
user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:53.0) Gecko/20100101 Firefox/53.0"

#-----------------------------------------------
# Snippet priority
#-----------------------------------------------

# Priority Importance:
#   This variable determines the order the tests are started,
#   they are processed in parallel. So even though these are started in order,
#   by default, the first answer to resolve is the one printed.
#   The order here might only make a very small difference.
# Priority Order:
#   The first word should be the name of the a_function() followed by a space;
#   You can disable tests by commenting out the line(s)
priority='
tracklist       # Album track lists ( eg: noisia outer edges tracklist )
richcast        # Rich Rich Answers ( eg: social network cast )
define          # Define ( eg: define Aggrandize )
lists           # Simple lists ( eg Need for Speed Heat cars list )
kno_val         # Chem facts ( eg: density of silver, density of hydrogen, what is the triple point of oxygen )
pronounce       # Learn to pronounce ( eg: pronounce linux )
lyrics_int      # Lyrics ( eg: gecgecgec lyrics )
weather         # Weather ( eg: weather new york )
math            # Math ( eg: log_2(3) * pi^e )
unit            # Units Conversion ( eg: 1m into 1 cm )
currency        # Currency Conversion ( eg: 1 USD in rupee )
kno_top         # Knowledge Graph - top ( list ) ( eg: the office cast )
basic           # Basic Answers ( eg: christmas day )
feat            # Featured Snippets ( eg: who is garfield )
quotes          # Quotes ( eg: mahatma gandhi quotes )
trans           # Translate ( eg: Vais para cascais? em ingles )
sport_fixture   # Shows last or next fixture of a sports team ( eg. Chelsea next game )
lyrics_us       # Lyrics for US users, above does not work for US
kno_right       # Knowledge Graph - right ( eg: the office )
'

#-----------------------------------------------
# Appereance
#-----------------------------------------------

N="\033[0m"    # Reset
B="\033[1m"    # Bold
R="\033[1;31m" # Bright Red
G="\033[1;32m" # Bright Green
Y="\033[1;33m" # Bright Yellow
M="\033[1;35m" # Bright Magenta
C="\033[1;36m" # Bright Cyan

#-----------------------------------------------
# macOS compatibility #149
#-----------------------------------------------

# to use it, you will need to have GNU core utils installed
case $OSTYPE in
darwin*)

    sed() {
        gsed "$@"
    }

    paste() {
        gpaste "$@"
    }

    ;;
esac

#-----------------------------------------------
# Defaults
#-----------------------------------------------

# system language fallback
LANG=$(echo $LANG | sed 's/\..*//')

# options
unset raw debug save_html pick_lang plus_urls

# all is a unstable variable... careful with it...
all=false; no_pipe=false; quiet=false; use_cache=false
pick_search=false; best_match=false

#-----------------------------------------------
# Help message
#-----------------------------------------------

help_text() {

    # When adding new information, keep it within 80 columns, including the
    #   indentation and the code. You don't want this important information
    #   needlessly wrapping on user's terminals; it's ugly and annoying.
    #
    #   Avoid ANSI color escape sequences here, too. Keep it simple to ensure
    #   the output is readable to ALL users, not just those of a given terminal
    #   type with a certain color configuration; the same goes for error MSGs.
    #
    #   Usage output like this is simply a quick reference; for anything
    #   more, refer and make changes to the tuxi(1) manual page.
    while read -r current_line; do
        printf '%b\n' "$current_line"
    done <<-EOF
        \rUsage: tuxi [OPTS] [QUERY]

        \r  -h                      - Display this help information.
        \r  -v                      - Print Tuxi version information.
        \r  -a                      - Print all valid answers.
        \r  -b                      - Auto-determine the best answer.
        \r  -c                      - Use cache from previous QUERY.
        \r  -d                      - Include debugging information.
        \r  -l LANG_[STR]           - Override LANG with STR.
        \r  -p                      - Disable pipe support.
        \r  -q                      - Output only query results.
        \r  -r                      - Output query in raw format.
        \r  -s [FILE]               - Save query result HTML to FILE.
        \r  -t                      - Choose answers to test.
        \r  -u                      - Print top bulk of query URLs.
EOF

}

#-----------------------------------------------
# Getopts
#   -r : raw output
#   -v : version info
#   -h : help
#   -q : silences greeting and did you mean
#   -a : print all answers
#   -b : best match
#   -t : specify answer type
#   -l : specify language using LANG_<code> - eg LANG_en_US
#   -d : print debug info
#   -s : save google HTML response
#   -c : use most recent cached results
#   -p : disable pipe support (needed for test script)
#   -u : also print out the top links
#-----------------------------------------------

while getopts "rvhqabtldscpu" OPT; do

    case $OPT in
    r)
        raw=1
        ;;
    v)
        printf "tuxi %s\n" "$VERSION"
        exit 0
        ;;
    h)
        help_text
        exit 0
        ;;
    q)
        quiet=true
        ;;
    a)
        all=true
        ;;
    b)
        best_match=true
        ;;
    t)
        pick_search=true
        ;;
    d)
        debug=1
        ;;
    s)
        save_html=1
        ;;
    c)
        use_cache=true
        ;;
    l)
        pick_lang=1
        ;;
    p)
        no_pipe=true
        ;;
    u)
        plus_urls=1
        ;;
    *)
        help_text | head -n 1
        exit 1
        ;;

    esac
done

# Shifts to query
shift $((OPTIND - 1))

# Only allow one option
$pick_search && $best_match && \
    echo "Sorry, but -b and -t are mutually exclusive." && exit 1

# TODO: Data handled by the user should probably be tested.
# question | tuxi [-flags] --> answer :)
if ! $no_pipe; then
  [ -p /dev/stdin ] && read query
fi

#-----------------------------------------------
# Output formatting
#   This will define how tuxi will return...
#   the results.
#-----------------------------------------------

# search result output format (changes if raw=true)
output() {
    printf "%b---%b\n%s\n%b---%b\n" "$G" "$N" "$*" "$G" "$N"
}

# If raw=true: No colors, No pretty output
[ $raw ] && {

    unset N B R G Y M C

    output() {
        printf "%s\n" "$*"
    }

}

info_msg() {
    printf "%b>%b %s\n" "$G" "$N" "$*"
}

error_msg() {
    printf "%b%s%b\n" "$R" "$*" "$N"
}

#-----------------------------------------------
# Dependency check
#   pup    : https://github.com/ericchiang/pup
#   recode : https://github.com/rrthomas/recode
#   jq     : https://github.com/stedolan/jq
#-----------------------------------------------

# Checks for required executable files in PATH.
check_deps() {
	  dep_err=0

    for dep in "$@"; do
      if ! command -v "$dep" 1> /dev/null 2>&1; then

            error_msg "\"$dep\" not found!"
			      dep_err=$((dep_err + 1))

      fi
    done

	  [ $dep_err -gt 0 ] && exit 2
}

check_deps pup recode jq

#-----------------------------------------------
# Query manipulation
#-----------------------------------------------

# Conditions to Query
#   If query is empty and -c is passed: use query from cached result
[ -z "$1" ] && [ -z "$query" ] && {

    # If query is empty (no -c): exit
    if ! $use_cache; then

        # If quiet=false: Prints greeting and usage
        if ! $quiet; then

            printf "Hi, I'm Tuxi. Ask me anything!\n"
            help_text | head -n 1

        fi
        exit 0

    else

        query=$(ls -1t $XDG_CACHE_HOME/tuxi | head -n1 | sed \
                -e 's/tuxi-*[[:digit:]]*-//' \
                -e 's/.html//' \
                -e 's/_/ /g')

    fi
  }

# Else, all arguments are saved in $query
[ -z "$query" ] && query="$*"

# language select: the -l flag
#   language specified on the command line overwrites both
#   the variable set at the top of this script and the system language
[ $pick_lang ] && {

       query=$(printf '%b\n' "$query" | sed 's/ /\\n/g')
    LANGUAGE=$(printf '%b\n' "$query" | grep 'LANG_' | sed 's/LANG_//g')
       query=$(printf '%b\n' "$query" | grep -v "LANG_" | sed 's/\\n/ /g')

}

# Custom Answers: the -t flag
#   Clears the list of snippets to check (saving the original list to print out if a mistake is made)
#   then loops through the query looking for tuxi_ and updates the priority variable to use only those snippets
$pick_search && {

    # Show list of valid 'tuxi_...' that the user can use
    warn_helpful_list() {


        [ $pick_words ] && {

            echo "Sorry but '$pick_words' is not a valid search type\n" \
                 "Please retry your search using one of the following:\n" \
                 "$(echo "$list_priority" | tail -n +1 | head -c -1 | sed \
                         -e 's/^/tuxi_/' \
                         -e '1 s/tuxi_//' )\n\n" \
                 "If '$pick_words' is on that list could you please file a bug report, thanks! (and sorry)\n"
             exit 1

        } || {

            echo "Sorry but I couldn't identify your search type\n" \
                 "Please retry your search using one of the following:\n" \
                 "$(echo "$list_priority" | tail -n +1 | head -c -1 | sed \
                         -e 's/^/tuxi_/' \
                         -e '1 s/tuxi_//' )\n\n" \
                 "If your search type is on that list could you please file a bug report, thanks! (and sorry).\n"
             exit 1

        }

    }

    list_priority="$priority"
    snippet_check=$(printf '%b\n' "$list_priority" | \
                    cut -d ' ' -f1 | sed -e '/^\s*#.*$/d' -e '/^\s*$/d')
            query=$(printf '%b\n' "$query" | sed 's/ /\\n/g')

    unset priority

    matched=false

    enabled_snippets=$(printf '%b\n' "$query" | grep 'tuxi_' | sed 's/tuxi_//g')

    # For every word "tuxi_..." clean it 
    for pick_words in $(printf "$enabled_snippets"); do

        # Check every "tuxi_..."
        for check_pick_words in $(printf '%b\n' "$snippet_check"); do

            [ "$check_pick_words" = "$pick_words" ] && {

                [ -z "$priority" ] && priority=$(printf '%s\n' "$pick_words") \
                                   || priority=$(printf '%b\n%s\n' "$priority" "$pick_words")
                matched=true

            }

        done

        # No matches? Print out the warning
        if ! $matched; then
            warn_helpful_list
        fi

    done

    # Double verification if the user typed any 'tuxi_...' whatsoever
    [ $enabled_snippets ] || warn_helpful_list

    query=$(printf '%b\n' "$query" | grep -v 'tuxi_' | sed 's/\\n/ /g')

}

# Smart Match
#   our patented (honest!) "smrt search" algorithm: the -b flag
#   jokes aside, this is going to need some iterating on, I'll turn it into a tidy loop later
# TODO: add more ways to identify a query
$best_match && {

    unset use_quotes use_lyrics use_weather use_cast \
          use_define use_list use_pronounce use_tracklist

    j=8

    query_check=$(printf '%b\n' "$query" | \
                  sed 's/ /\\n/g' | tr '[:upper:]' '[:lower:]')
     first_word=$(printf '%b\n' "$query_check" | head -n1)
      last_word=$(printf '%b\n' "$query_check" | tail -n1)

    for keywords in printf '%s\n%s\n' "$first_word" "$last_word"; do

        case $keywords in
            quote | quotes)            use_quotes=1    ;;
            lyrics)                    use_lyrics=1    ;;
            weather)                   use_weather=1   ;;
            cast)                      use_cast=1      ;;
            define | definition)       use_define=1    ;;
            list)                      use_list=1      ;;
            pronounce | pronunciation) use_pronounce=1 ;;
            tracklist | songs)         use_tracklist=1 ;;
        esac

    done

    [ $use_define ] && priority=$(printf '%b\n' "$priority" | cut -d ' ' -f1 | grep 'define') || j=$(($j - 1))
    [ $use_quotes ] && priority=$(printf '%b\n' "$priority" | cut -d ' ' -f1 | grep 'quotes') || j=$(($j - 1))
    [ $use_lyrics ] && priority=$(printf '%b\n' "$priority" | cut -d ' ' -f1 | grep 'lyrics') || j=$(($j - 1))
    [ $use_weather ] && priority=$(printf '%b\n' "$priority" | cut -d ' ' -f1 | grep 'weather') || j=$(($j - 1))
    [ $use_pronounce ] && priority=$(printf '%b\n' "$priority" | cut -d ' ' -f1 | grep 'pronounce') || j=$(($j - 1))
    [ $use_tracklist ] && priority=$(printf '%b\n' "$priority" | cut -d ' ' -f1 | grep 'tracklist') || j=$(($j - 1))
    [ $use_cast ] && priority=$(printf '%b\n' "$priority" | cut -d ' ' -f1 | grep -e 'lists' -e 'kno_') || j=$(($j - 1))
    [ $use_list ] && priority=$(printf '%b\n' "$priority" | cut -d ' ' -f1 | grep -e 'lists' -e 'kno_') || j=$(($j - 1))

    [ $j -eq 0 ] && priority=$(printf '%b\n' "$priority" | cut -d ' ' -f1 | sed \
                                  -e '/^\s*#.*$/d' \
                                  -e '/^[[:space:]]*$/d' | grep \
                                  -v 'quotes' | grep \
                                  -v 'lyrics' | grep \
                                  -v 'weather')

}

#-----------------------------------------------
# Answer functions
#-----------------------------------------------

# Used to call shup to scrape the HTML.
clean_html() {
    echo "$google_html" | pup "$1"
}

# Used to call simple recode to clean HTML special characters
clean_recode() {
    recode html..ISO-8859-1
}

# The following divs have been removed due to seemingly being redundant
# Im leaving them here just in case they're needed again in future
#..................................................
# div.ujudUb (seems to be another lyrics scrape)
# div.XcVN5d (deprecated because Google UI update)
#..................................................
# FUNCTION TEMPLATE
# NewAnswerName should be the word used in $priority
#..............................................................
# a_NewAnswerName() { # Answer description (and example)
#     clean_html ... [ SCRAPE METHOD HERE ] ...
# }
#..............................................................
# NOTE: the order of these functions doesn't matter, priority is determined by the variable

# this div is google's top line answer, works for simple dates, values etc
# eg: density of silver, what is the triple point of oxygen, elevation of mount everest, christmas day
# "what is the " seems to be required for some things
a_kno_val() {
    clean_html 'div.Z0LcW.XcVN5d text{}' | tr '\n' ' '
}

# Math ( eg: log_2(3) * pi^e )
a_math() {
    clean_html 'span.qv3Wpe text{}' | tr -d '\n '
}

# Knowledge Graph - top (list) ( eg: the office cast )
a_kno_top() {
    clean_html 'div.dAassd json{}' | jq -r '.[] | .children | .[] | .text' | \
               sed ':a;N;$!ba;s/\n/ /g;s/null/\n/g' | \
               sed '1s/.*/* &/;2,$s/.*/*&/;$d' | clean_recode
}

# Quotes ( eg: mahatma gandhi quotes )
a_quotes() {
    clean_html 'div.Qynugf text{}' | clean_recode
}

# Basic Answers ( eg: summer solstice || easter )
# this displays similar info to kno_val but uses a different div in the google results 
a_basic() {
    clean_html 'div.zCubwf text{}' | tr -d '\n' | clean_recode
}

# Rich Rich Answers ( eg: social network cast )
a_richcast() {
    clean_html 'a.ct5Ked json{}' | jq -r '.[] | .title' | sed 's/^/* /' | clean_recode
}

# Featured Snippets ( eg: who is garfield )
a_feat() {
    clean_html 'span.hgKElc text{}' | tr -d '\n' | clean_recode | tr ' ' '\0' | xargs -0 -n10
}

# Lyrics ( eg: gecgecgec lyrics )
a_lyrics_int() {
    clean_html 'div.bbVIQb text{}' | clean_recode
}

# Lyrics for US users, above does not work for US
a_lyrics_us() {
    clean_html 'span[jsname="YS01Ge"] text{}' | clean_recode
}

# Units Conversion ( eg: 1m into 1 cm )
a_unit() {
    clean_html '#NotFQb json{}' | jq -r '.[] | .children | .[0] | .value' | clean_recode
}

# Currency Conversion ( eg: 1 USD in rupee )
a_currency() {
    clean_html '.SwHCTb text{}' | sed 's/\n//g;s/\ /\0/g' | clean_recode
}

# Translate ( eg: Vais para cascais? em ingles )
a_trans() {
    clean_html 'pre.XcVN5d json{}' | \
              jq -r '[.[] | .children | .[] | select(.class!="BCGytf")][1] | .text' | \
              sed 's/null//g' | clean_recode
}

# Knowledge Graph - right ( eg: the office )
a_kno_right() {
    clean_html 'div.kno-rdesc span' | sed -n '2p' | awk '{$1=$1;print}' | \
                clean_recode | tr ' ' '\0' | xargs -0 -n10
}

# Learn to pronounce ( eg: pronounce linux )
a_pronounce() {
    clean_html 'div.fQ02Rb.eDzgme span.seLqNc text{}' | paste -s -d ' ' | sed 's/\s/∙/g'
}

# Simple lists (eg: how to exit vim || how to update windows)
a_lists() {
    lists=$(clean_html 'div.co8aDb.XcVN5d, li.TrT0Xe' | sed 's/^[[:blank:]]*//g' | clean_recode)

    [ -n "$lists" ] && {
        lists_num=0

        printf '%s\n' "$lists" | while IFS= read -r lists_foo; do

            case "$lists_foo" in
            "<div "*) continue         ;;
            "</div>") printf '\n'      ;;
            "<b>")    printf '%b' "$B" ;;
            "</b>")   printf '%b' "$N" ;;
            "<li "*)
                lists_num=$(($lists_num + 1))
                printf '%s%b)%b\t' "$lists_num" "$Y" "$N"
                ;;
            "</li>") printf '\n'               ;;
            *)       printf '%s ' "$lists_foo" ;;
            esac

        done

      }
}

# Weather ( eg: weather new york)
a_weather() {
    weather=$(clean_html 'div.UQt4rd json{}' | jq -r '.. | .text?, .alt?' | \
              sed '/null/d' | sed '$!N; /^\(.*\)\n\1$/!P; D')

    [ -n "$weather" ] && {
        [ $(echo "$weather" | sed -n 2p) -gt $(echo "$weather" | sed -n 3p) ] && {

            weather=$(printf '%b\n' "$weather" | sed \
                      -e 2','3'!b' \
                      -e ''2'h;'2'!H;'3'!d;x;s/^\([[:print:]'"$(printf \
'\001\002\003\004\005\006\007\010\011\013\014\015\016\017\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037\177')"']*\)\(.*\n\)\(.*\)/\3\2\1/')

        }
        printf '%b\n' "$weather" | \
            sed '4,5d;2s/.*/&ºC/;2,${N;s/\n/\t/;};3s/.*/&ºF/;$s/\t/\t\t/' | clean_recode
    }
}

# Shows last or next fixture of a sports team ( eg. Chelsea next game )
a_sport_fixture() {
    sport_fixture=$(clean_html 'span[jscontroller="f9W5M"] text{}' | clean_recode)

    [ -n "$sport_fixture" ] && {
        
        # Honestly, we need to find an alternative to this "hard" patched 
        case $sport_fixture in
            "Premier League"          | "EFL "*                 | \
            "FA "*                    | "MLS"                   | \
            "Canadian Premier League" | "USL "*                 | \
            "UEFA "*                  | "Ligue "*               | \
            "Coupe de France"         | "Trophée des Champions" | \
            *"Bundesliga"             | "DFB-Pokal"             | \
            "Serie "*                 | "Coppa Italia"          | \
            "Supercoppa Italiana"     | "Eredivisie"            | \
            "Eerste Divisie"          | "Tweede Divisie"        | \
            "KNVB "*                  | "Johan Cruijff"*        | \
            "Scottish Premiership"    | "Scottish Championship" | \
            "Scottish Cup"            | "Scottish League Cup"   | \
            "La Liga"                 | "Segunda División"      | \
            "Tercera División"        | "Copa del Rey"          | \
            "Supercopa de España"     | "Copa Federación"       | \
            "Allsvenskan"             | "Superettan"            | \
            "Svenska Cupen"           | "Swiss Super League"    | \
            "Swiss Challenge League"  | "Schweizer Cup"         | \
            "Uhrencup")
            sf_use_new=1 ;;

          *) unset sf_use_new ;;
        esac

        [ $sf_use_new ] && {

            sport_fixture=$(clean_html 'div.imso_mh__tm-scr text{}' | clean_recode)
            sfi=1 # <-- this is used as both a loop counter and name for our new variables

            printf '%b\n' "$sport_fixture" | { # <-- the braces are needed because while/read is executed in a subshell...
                # this means that as soon as the loop has finished it will exit the new process and "forget" everything
                # if we encapsulate the whole loop and processing code in the braces, we get to use the data

                while IFS= read -r sfx; do # read the contents of $sport_fixture line by line...
                    # ...saving the text from each line in the variable $sfx and *do*ing the following:

                    eval sf${sfi}=\"\${sfx}\" # use eval to declare a new variable using two different variables...
                    # we use sf and then the line number for that text string for the name of the variable (eg: $sf1)
                    # and the value of the new variable is going to be the current value of $sfx
                    # when using eval this way the value side of the declaration has to be properly escaped

                    sfi=$(($sfi + 1)) # i++ - increment the loop counter and more importantly the next variable name

                    [ $sfi -eq 10 ] && break # we don't need any of the information after the ninth line...
                    # so we can just use break to exit the loop when the counter hits ten

                done # <-- normally after this point everything processed above would be gone...
                # but because we are still within the braces we get to do some checks on the data we have

                # check if match is in progress
                if [ "$sf3" != ' · ' ]; then

                    # match is underway
                    [ "$sf2" = "'" ] && {

                        # match is underway, score is a draw
                        if [ $sf5 -eq $sf7 ]; then
                            printf '%s\n%b%s\t%s\n%s\t%s%b\n%s %b%s%s%b\n' \
                                   "$sf3" "$B" "$sf5" "$sf4" "$sf7" "$sf8" \
                                   "$N" "$sf6" "$G" "$sf1" "$sf2" "$N"

                        # match is underway, team one is winning
                        elif [ $sf5 -gt $sf7 ]; then
                            printf '%s\n%b%s\t%s\n%b%b%s\t%s%b\n%s %b%s%s%b\n' \
                                   "$sf3" "$C" "$sf5" "$sf4" "$N" "$B" "$sf7" \
                                   "$sf8" "$N" "$sf6" "$G" "$sf1" "$sf2" "$N"

                        # match is underway, team two is winning
                        else
                            printf '%s\n%b%s\t%s\n%b%s\t%s%b\n%s %b%s%s%b\n' \
                                   "$sf3" "$B" "$sf5" "$sf4" "$C" "$sf7" "$sf8" \
                                   "$N" "$sf6" "$G" "$sf1" "$sf2" "$N"
                        fi

                    # half time
                    } || {

                        # match is even
                        if [ $sf4 -eq $sf6 ]; then
                            printf '%s\n%b%s\t%s\n%s\t%s\n%b%s %b%s%b\n' \
                                "$sf2" "$B" "$sf4" "$sf3" "$sf6" "$sf7" "$N" \
                                "$sf5" "$R" "$sf1" "$N"
                        # team one winning
                        elif [ $sf4 -gt $sf6 ]; then
                            printf '%s\n%b%s\t%s\n%b%b%s\t%s\n%b%s %b%s%b\n' \
                                "$sf2" "$C" "$sf4" "$sf3" "$N" "$B" "$sf6" \
                                "$sf7" "$N" "$sf5" "$R" "$sf1" "$N"
                        # team two winning
                        else
                            printf '%s\n%b%s\t%s\n%b%s\t%s\n%b%s %b%s%b\n' \
                                "$sf2" "$B" "$sf4" "$sf3" "$C" "$sf6" "$sf7" \
                                "$N" "$sf5" "$R" "$sf1" "$N"
                        fi

                    }

                # check if the match has happened or is upcomming
                elif [ -n "$sf9" ]; then

                    # match has finished
                    if [ $sf6 -eq $sf8 ]; then
                        # scores are even
                        printf '%s%s%s\n%b%s\t%s\n%s\t%s%b\n%s %s\n' \
                               "$sf4" "$sf3" "$sf2" "$B" "$sf6" "$sf5" \
                               "$sf8" "$sf9" "$N" "$sf7" "$sf1"

                    elif [ $sf6 -gt $sf8 ]; then
                        # team one has won
                        printf '%s%s%s\n%b%s\t%s%b%b\n%s\t%s%b\n%s %s\n' \
                               "$sf4" "$sf3" "$sf2" "$C" "$sf6" "$sf5" "$N" \
                               "$B" "$sf8" "$sf9" "$N" "$sf7" "$sf1"

                    else
                        # team two has won
                        printf '%s%s%s\n%b%s\t%s\n%b%s\t%s%b\n%s %s\n' \
                               "$sf4" "$sf3" "$sf2" "$B" "$sf6" "$sf5" \
                               "$C" "$sf8" "$sf9" "$N" "$sf7" "$sf1"
                    fi

                else
                    # match is upcomming
                    printf '%b%b%b\n%b%b%b %b %b%b%b\n' \
                           "$sf3" "$sf2" "$sf1" "$B" "$sf4" \
                           "$N" "$sf5" "$B" "$sf6" "$N"
                fi
            } # <-- and here is where the subshell ends and the rest of the snippet code falls through to exit
        }

    } || {
        clean_html 'span.imso_mh__lr-dt-ds, span[jscontroller="f9W5M"], div.liveresults-sports-immersive__team-name-width span, div.imso_mh__l-tm-sc, div.imso_mh__r-tm-sc text{}' | clean_recode
    }
}

# Album track lists ( eg: noisia outer edges tracklist )
a_tracklist() {
    tracklist=$(clean_html 'div.mR2gOd json{}')

    [ -n "$tracklist" ] && {

        tracklist_songs=$(printf '%s\n' "$tracklist" \
            | jq -r '.[0].children[0].children[].children[0].children[].children[0].children[0].children[1].children[1].children[0].children[0].text' \
            | sed '/^null$/d' | clean_recode)

        [ -z "$tracklist_songs" ] && tracklist_songs=$(printf '%s\n' "$tracklist" \
            | jq -r '.[0].children[0].children[].children[0].children[].children[0].children[0].children[1].children[0].children[0].children[0].text' \
            | sed '/^null$/d' | clean_recode)

        [ -z "$tracklist_songs" ] && exit
        
        # Nothing yet? Yew...
        tracklist_links="$(printf '%s\n' "$tracklist" | jq -r '.[1].children[0].children[0].children[].href' | sed '/^null$/d')"

        #
        printf '%s\n' "$tracklist_links" | grep -q 'youtube.com' || unset tracklist_links

        [ -n "$tracklist_links" ] && tracklist_use_links=1 || unset tracklist_use_links

        tracklist_title=$(clean_html 'div.SPZz6b text{}' | clean_recode)
        [ -n "$tracklist_title" ] && printf '%b%s%b (%s)\n' "$C" \
            "$(printf '%s\n' "$tracklist_title" | head -n1)" "$N" \
            "$(printf '%s\n' "$tracklist_title" | tail -n1)"

        tracklist_i=1

        printf '%s\n' "$tracklist_songs" | while IFS= read -r tracklist_foo; do
            printf '%s%b)%b\t%b%s%b\n' "$tracklist_i" "$Y" "$N" "$B" "$tracklist_foo" "$N"
            tracklist_i=$(($tracklist_i + 1))
        done

        [ $tracklist_use_links ] && {

            [ $raw ] || printf '%b---%b\n' "$G" "$N"
            printf '%bassociated video links:%b\n' "$R" "$N"
            printf '%s\n' "$tracklist_links"

        }

    }
}

# Define (eg: define Aggrandize)
a_define() {

    # If it's not english, then do not use the _advanced_ script.
    case $LANGUAGE in
      en_*) dfn_use_new=1     ;;
      *)    unset dfn_use_new ;;
    esac

    [ $dfn_use_new ] && {

        define=$(clean_html 'div.VpH2eb.dZd3De.vmod text{}' | \
                 sed '/^[[:space:]]*$/d' | clean_recode)

        [ -n "$define" ] && {

            printf 'pronounced: %b%s%b\n\n' "$C" $(printf '%s\n' "$define" | \
                grep -m1 -A1 -w '/' | tail -n1) "$N"
            dfn_top=1

            unset dfn_end_top dfn_start dfn_append dfn_marker dfn_sim_op dfn_skip

            printf '%s\n' "$define" | while IFS= read -r dfn_foo; do
              if $dfn_top; then
                  [ $dfn_end_top ] && {
                      case $dfn_foo in

                      *"noun: "        | *"verb: "       | *"adjective: "   | \
                      *"adverb: "      | *"pronoun: "    | *"preposition: " | \
                      *"conjunction: " | *"determiner: " | *"exclamation: ")
                      printf '%s ' "$dfn_foo"
                      dfn_append=1
                      ;;

                      *"noun:"        | *"verb:"       | *"adjective:"   | \
                      *"adverb:"      | *"pronoun:"    | *"preposition:" | \
                      *"conjunction:" | *"determiner:" | *"exclamation:")
                      printf '%s ' "$dfn_foo"
                      dfn_append=1
                      ;;

                      *) printf '%b%s%b\n\t%b%s%b\n' "$Y" "$dfn_backup" \
                                "$N" "$B" "$dfn_foo" "$N" ;;
                      esac

                      unset dfn_top

                  } || {

                      case $dfn_foo in
                      noun       | verb        | adjective   | adverb | \
                      pronoun    | preposition | conjunction | \
                      determiner | exclamation)
                      dfn_backup="$dfn_foo"
                      dfn_end_top=1
                      ;;
                      *) continue ;;
                      esac

                  }

              elif $dfn_append; then
                  printf '%b%s%b\n' "$C" "$dfn_foo" "$N"
                  unset dfn_append

              elif [ $dfn_foo -eq $dfn_foo ] 2>/dev/null; then
                  printf '\n'
                  [ $dfn_sim_op ] && unset dfn_sim_op

              elif [ "$dfn_foo" = '/' ]; then
                  [ $dfn_skip ] && unset dfn_skip || dfn_skip=1

              elif $dfn_skip; then
                  continue

              elif [ "$dfn_foo" = '. ' ]; then
                  [ $dfn_sim_op ] && unset dfn_sim_op

              elif [ "$dfn_foo" = '.' ]; then
                  printf '\n'
                  [ $dfn_sim_op ] && unset dfn_sim_op

              elif $dfn_marker; then
                  [ "$dfn_foo" = 'Similar:' ] && dfn_hl="$G" || dfn_hl="$R"
                  printf '%b%s%b\n' "$dfn_hl" "$dfn_foo" "$N"
                  unset dfn_marker
                  dfn_sim_op=1

              elif $dfn_start; then
                  case $dfn_foo in
                  informal) printf '(informal) ' ;;
                  British)  printf '(British) '  ;;
                  rare)     printf '(rare) '     ;;
                  *)
                      printf '%s ' "$dfn_foo"
                      dfn_append=1
                      unset dfn_start
                  ;;
                  esac

              else
                  case $dfn_foo in
                  "; "*)
                      printf '%s ' "$dfn_foo"
                      dfn_append=1
                      ;;
                  *"noun: "       | *"verb: "        | *"adjective: "   | \
                  *"adverb: "      | *"pronoun: "    | *"preposition: " | \
                  *"conjunction: " | *"determiner: " | *"exclamation: ")
                      printf '\n%s ' "$dfn_foo"
                      [ $dfn_sim_op ] && unset dfn_sim_op
                      dfn_append=1
                      ;;
                  " h ")
                      dfn_marker=1
                      ;;
                  noun | verb | adjective | adverb | \
                  pronoun | preposition | conjunction | \
                  determiner | exclamation)
                      printf '\n'
                      [ $dfn_sim_op ] && unset dfn_sim_op
                      dfn_start=1
                      ;;
                  *)
                      [ $dfn_sim_op ] && printf '\t%s\n' "$dfn_foo" \
                                      || printf '\t%b%s%b\n' "$B" "$dfn_foo" "$N"
                    esac
                fi
            done
        }
    } || {
        clean_html 'div.DgZBFd, div.vdBwhd, div[data-dobid="dfn"] text{}' | sed -e 's/^/* /' -e '1 s/^* //' | clean_recode
    }

}

#-----------------------------------------------
# Functions to process all information
#-----------------------------------------------

# these are used by the processing loop to determine how and when to print info and exit
#   USR1
found_answer_signal() {
    answers_found=$(($answers_found + 1))
}
trap found_answer_signal USR1

#   USR2
output_printed_signal() {
    printed=$(($printed + 1))
}
trap output_printed_signal USR2

# Waiting signals to continue:
#   Without this the main script assumes that fork doesn't have an answer
#   ready because it checks the printed variable too fast and sends
#   the signal to print to another fork and that's how you get multiple
#   answers being printed out. So be careful with this.
short_delay() {

    [ ! $1 ] && runs=1 || runs=$1
    foo=0

    until [ $foo -eq $runs ]; do
        l=0

        until [ $l -eq $MICRO_DELAY ]; do
            [ true ]
            l=$(($l + 1))
        done

        foo=$(($foo + 1))
    done

}

# Calculates execution time and number of answers processed
debug_info() {
 
          timer_stop=$(date +'%s %N')
    timer_start_secs=$(echo $timer_start | cut -d ' ' -f1)
     timer_stop_secs=$(echo $timer_stop | cut -d ' ' -f1)
    timer_start_nano=$(echo $timer_start | cut -d ' ' -f2)
    timer_start_nano=$(expr $timer_start_nano + 0)
     timer_stop_nano=$(echo $timer_stop | cut -d ' ' -f2)
     timer_stop_nano=$(expr $timer_stop_nano + 0)
     timer_secs_math=$(($timer_stop_secs - $timer_start_secs))

    if [ $timer_secs_math -lt 1 ]; then

        timer_duration=$(($timer_stop_nano - $timer_start_nano))
        timer_duration=$(($timer_duration / 1000))

        [ $timer_duration -gt 1999 ] &&  {

            timer_duration=$(($timer_duration / 1000))
            timer_unit='ms'

        } || timer_unit='μs'

    elif [ $timer_secs_math -eq 1 ]; then

        # Set time duration based on 
        timer_duration=$((1000000000 - $timer_start_nano))
        timer_duration=$(($timer_duration + $timer_stop_nano))
        timer_duration=$(($timer_duration / 1000))

        [ $timer_duration -gt 1999 ] && {

            timer_duration=$(($timer_duration / 1000))
            timer_unit='ms'

        } || timer_unit='μs'

    else

        timer_duration="$timer_secs_math"
            timer_unit='s'

    fi

    info_msg "$answers_found answer(s) found - post curl processing time ~$timer_duration $timer_unit"
}

# Enabled with the -s flag to dump the HTML file given by curl
dump_html() {

    # Creates folder if it doesn't exist
    [ -d "$XDG_CACHE_HOME"/tuxi ] || mkdir -p "$XDG_CACHE_HOME/tuxi"

        file_name="$(date +%s%N)-$(printf %s "$query" | sed 's/ /_/g').html"
    html_location="$XDG_CACHE_HOME/tuxi/$file_name"

    # Send file and tells user its path.
    printf "%s" "$google_html" > $html_location
    info_msg "HTML for \"$query\" -> $html_location"

}

# This calls the various snippet functions and checks for valid answers
test_answers() {

    print_answer_signal() {
        [ -n "$z" ] && {

            kill -USR2 "$MAIN_PID"
            [ $debug ] && info_msg "Answer selected: $the_chosen_one"
            output "$z"
            kill "$sleep_pid"

        }
    }
    trap print_answer_signal USR1

    z=$(a_${1})
    [ -n "$z" ] && {
        the_chosen_one="$1"

        if ! $all; then
            kill -USR1 "$MAIN_PID"
            sleep 1 &
            sleep_pid="$!"
            wait
        else
            kill -USR1 "$MAIN_PID"
            [ $debug ] && output "$(printf '%b\n\n%b\n' "$(info_msg "Answer selected: $the_chosen_one")" "$z")" || output "$z"
        fi
    }
}

# This finds and prints out the top links for your query
top_links() {
    url_list=$(echo "$google_html" | pup 'div.tF2Cxc json{}' \
        | jq -r '.[].children[0].children[0].children[1].text, .[].children[0].children[0].children[1].children[0].text, .[].children[0].children[0].href' \
        | sed '/^null$/d' | recode html..ISO-8859-1)

    [ -n "$url_list" ] && {

        [ -n "$1" ] && {
            info_msg "Sorry about that! Perhaps one of these links may be of use?"
            $raw || printf '%b---%b\n' "$G" "$N"
        }

        links_num=$(($(printf '%s\n' "$url_list" | wc -l) / 2))
        links_i=1

        printf '%s\n' "$url_list" | {

            while IFS= read -r links_foo; do
                eval links_bar_${links_i}=\"\${links_foo}\"
                links_i=$(($links_i + 1))
            done

            links_i=1

            until [ $links_i -gt $links_num ]; do
                links_j=$(($links_i + $links_num))
                printf '%b%s%b\n%s\n' "$C" "$(eval echo \"\$links_bar_${links_i}\")" \
                    "$N" "$(eval echo \"\$links_bar_${links_j}\")"
                links_i=$(($links_i + 1))
            done
        }
        $raw || printf '%b---%b\n' "$G" "$N"
    }
}

#-----------------------------------------------
# Getting the HTML
#-----------------------------------------------

# Fetch response from Google via cURL (-G: get, -s: silent) unless -c flag is passed
# in which case we use the most recent cached html from $XDG_CACHE_HOME/tuxi
google_url="https://www.google.com/search?hl="${LANGUAGE:="${LANG:=en_US}"}""

$use_cache && google_html=$(cat $XDG_CACHE_HOME/tuxi/$(ls -1t $XDG_CACHE_HOME/tuxi | head -n1))

[ -z "$google_html" ] && {

    $use_cache && printf 'no cached pages found!\n' && exit 1
    google_html=$(curl -Gs --compressed "$google_url" --user-agent "$user_agent" --data-urlencode "q=$query")

    [ -z "$google_html" ] && error_msg "No valid response from google!" && exit 1

}

# if -s flag is passed save search results for debugging
[ $save_html ] && dump_html

# start timer for debug_info after receiving results from google
[ $debug ] && timer_start=$(date +'%s %N')

#-----------------------------------------------
# Processing
#-----------------------------------------------

# launches all the snippet functions and saves the pids for later
unset pids

answers_found=0
      printed=0

if ! $pick_search || ! $best_match; then
    priority=$(printf '%b\n' "$priority" | cut -d ' ' -f1 | \
               sed -e '/^\s*#.*$/d' -e '/^[[:space:]]*$/d')
fi

# loops through $priority forking all the tests in order
for tests in $(printf '%b\n' "$priority"); do
    test_answers "$tests" 2>/dev/null &
    [ -z "$pids" ] && pids="$!" || pids="${pids}\n${!}"
done

# did you mean is processed here to make controling the order things get printed easier
# forking the tests makes things faster (hopefully) but makes passing information around harder
if ! $quiet; then

    # silenced if quiet=true
    did_you_mean=$(clean_html 'a.gL9Hy text{}')

    [ -n "$did_you_mean" ] && {
              err_hl=$(clean_html 'a.gL9Hy > b text{}')
        did_you_mean=$(printf '%b\n' "$did_you_mean" | sed ':a;N;$!ba;s/\n//g' | clean_recode)

        for errors in $(printf '%b\n' "$err_hl"); do
             replacement="${C}${errors}${N}${B}"
             replacement=$(printf '%s\n' "$replacement" | sed -e 's/[\/&]/\\&/g')
            did_you_mean=$(printf '%b\n' "$did_you_mean" | sed "s/${errors}/${replacement}/g")
        done

        info_msg $(printf 'did you mean "%b%b%b" ?\n' "$B" "$did_you_mean" "$N")
    }
fi

# loops to spin wheels until an answer has been found
# if all the launched processes exit without an answer being found
# script exits with a "No Result!" message
while [ $answers_found -eq 0 ]; do
    for waiting1 in $(printf '%b\n' "$pids"); do

        kill -0 "$waiting1" 1>/dev/null 2>&1
        [ $? -eq 0 ] && break

        for waiting2 in $(printf '%b\n' "$pids"); do
            kill -0 "$waiting2" 1>/dev/null 2>&1
            [ $? -eq 0 ] && break 2
        done

        error_msg "No Result!"

        $quiet || top_links 1
        [ $debug ] && debug_info
        exit 1

    done
done

# Now we have our first answer, it's time to print it
# this loops through the child pid list in priority order sending the USR1 kill signal
# if one has an answer ready that is what gets printed out
#
# "all" is a fucking unstable variable, please, be careful with it
if ! $all; then
    for lucky_winner in $(printf '%b\n' "$pids"); do
        [ $printed -gt 0 ] && break
        kill -0 "$lucky_winner" 1>/dev/null 2>&1
        if [ $? -eq 0 ]; then
            kill -USR1 "$lucky_winner" 1>/dev/null 2>&1
            short_delay
        fi
    done
fi

# once an answer has been printed and the -a flag isn't active
# kills all remaining child processes
# if -a flag is active then it waits until every answer has been printed first
if ! $all; then
    for kids in $(printf '%b\n' "$pids"); do
        kill -0 "$kids" 1>/dev/null 2>&1
        [ $? -eq 0 ] && kill "$kids" 1>/dev/null 2>&1
    done
fi

$all && wait

# another small delay as wait sometimes doesn't seem to wait quite long enough
# for the last answer to be printed before exiting.
short_delay 2
[ $plus_urls ] && top_links
[ $debug ]     && debug_info
exit 0

#-----------------------------------------------
# Lovely contributors 
#   We're going to find a better place to put 
#   y'all.
#-----------------------------------------------

# @Zhann
# @sudocanttyp
# @sdushantha
# @PureArtistry
# @PoseidonCoder
# @karthink
# @jhagas
# @ismayilkarimli
# @igaurab
# @Genghius
# @d-shaun
# @BeyondMagic
